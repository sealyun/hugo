+++
author = "fanux"
date = "2018-11-06T10:54:24+02:00"
draft = false
title = "kubernetes源码分析之kube-scheduler - 扩展调度器"
tags = ["event","dotScale","sketchnote"]
comments = true     # set false to hide Disqus comments
share = true        # set false to share buttons
menu = ""           # set "main" to add this content to the main menu
+++

> [kubernetes集群三步安装](https://sealyun.com/pro/products/)

# kube-scheduler源码分析

## 调度器扩展
定制化调度器有三种方式：
* 改scheduler代码重新编译 - 没啥可讨论
* 重写调度器，调度时选择调度器 - 比较简单，问题是没法与默认调度器共同作用
* 写调度器扩展（extender）让k8s调度完了 把符合的节点扔给你 你再去过滤和优选 - 重点讨论，新版本做了一些升级，老的方式可能都无用了 [资料](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/scheduler_extender.md)
* 这里有个调度器扩展[事例](https://github.com/everpeace/k8s-scheduler-extender-example)

目前第三点资料非常少，很多细节需要在代码里找到答案，带着问题看代码效果更好。

## 调度算法
```
▾ algorithm/
  ▸ predicates/  预选
  ▸ priorities/  优选
```

## Extender接口
```
+----------------------------------+       +----------+
| kube-scheduler -> extender client|------>| extender | (你需要开发的扩展，单独的进程)
+----------------------------------+       +----------+
```

这个接口是kube-scheduler实现的，下面会介绍HTTPextender的实现
```
type SchedulerExtender interface {
    // 最重要的一个接口，输入pod和节点列表，输出是符合调度的节点的列表
	Filter(pod *v1.Pod,
		nodes []*v1.Node, nodeNameToInfo map[string]*schedulercache.NodeInfo,
	) (filteredNodes []*v1.Node, failedNodesMap schedulerapi.FailedNodesMap, err error)

    // 这个给节点打分的，优选时需要用的
	Prioritize(pod *v1.Pod, nodes []*v1.Node) (hostPriorities *schedulerapi.HostPriorityList, weight int, err error)

    // Bind接口主要是最终调度器选中节点哪个节点时通知extender
	Bind(binding *v1.Binding) error

	// IsBinder returns whether this extender is configured for the Bind method.
	IsBinder() bool

    // 可以过滤你感兴趣的pod 比如按照标签
	IsInterested(pod *v1.Pod) bool

	// ProcessPreemption returns nodes with their victim pods processed by extender based on
	// given:
	//   1. Pod to schedule
	//   2. Candidate nodes and victim pods (nodeToVictims) generated by previous scheduling process.
	//   3. nodeNameToInfo to restore v1.Node from node name if extender cache is enabled.
	// The possible changes made by extender may include:
	//   1. Subset of given candidate nodes after preemption phase of extender.
	//   2. A different set of victim pod for every given candidate node after preemption phase of extender.
    // 我猜是与亲和性相关的功能，不太清楚 TODO
	ProcessPreemption(
		pod *v1.Pod,
		nodeToVictims map[*v1.Node]*schedulerapi.Victims,
		nodeNameToInfo map[string]*schedulercache.NodeInfo,
	) (map[*v1.Node]*schedulerapi.Victims, error)

    // 优先级抢占特性，可不实现
	SupportsPreemption() bool

    // 当访问不到extender时怎么处理，返回真时extender获取不到时调度不能失败
	IsIgnorable() bool
}
```

官方实现了HTTPextender，可以看下：
```
type HTTPExtender struct {
	extenderURL      string
	preemptVerb      string
	filterVerb       string  # 预选RUL
	prioritizeVerb   string  # 优选RUL
	bindVerb         string
	weight           int
	client           *http.Client
	nodeCacheCapable bool
	managedResources sets.String
	ignorable        bool
}
```

看其预选和优选逻辑：
```
args = &schedulerapi.ExtenderArgs{  # 调度的是哪个pod，哪些节点符合调度条件, 返回的也是这个结构体
	Pod:       pod,
	Nodes:     nodeList,
	NodeNames: nodeNames,
}

if err := h.send(h.filterVerb, args, &result); err != nil { # 发了个http请求给extender(你要去实现的httpserver), 返回过滤后的结构
	return nil, nil, err
}
```

## HTTPExtender配置参数从哪来

## scheduler extender配置：
```
NamespaceSystem string = "kube-system"

SchedulerDefaultLockObjectNamespace string = metav1.NamespaceSystem

// SchedulerPolicyConfigMapKey defines the key of the element in the
// scheduler's policy ConfigMap that contains scheduler's policy config.
SchedulerPolicyConfigMapKey = "policy.cfg"
```

## 关于源码编译
我嫌弃官方提供的编译脚本太麻烦，所以用了更简单粗暴的方式编译k8s代码，当然官方脚本在编译所有项目或者夸平台编译以及realse时还是挺有用的。

在容器中编译：
```
docker run -v /work/src/k8s.io/kubernetes:/go/src/k8s.io/kubernetes golang:1.11.2 bash
```

在容器中可以保证环境干净

进入bash后直接进入kube-scheduler的主目录编译即可

```
cd cmd/kube-scheduler && go build
```
二进制就产生了。。。

### 源码编译接入CI/CD
作为高端玩家，自动化是必须的，因为服务器性能更好，用CI/CD编译更快，这里分享一下我的一些配置:

1. 我把vendor打到编译的基础镜像里了，因为vendor大而且不经常更新
```
$ cat Dockerfile-build1.12.2
FROM golang:1.11.2
COPY vendor/ /vendor
```
然后代码里的vendor就可以删了

2. .drone.yml
```
workspace:
  base: /go/src/k8s.io
  path: kubernetes

pipeline:
    build:
        image: fanux/kubernetes-build:1.12.2-beta.3
        commands:
           - mv /vendor ./vendor    # 本来想用软链的，不知道为啥ln后编译不了，导致多用了十几秒，难以接受
           - cd cmd/kube-scheduler
           - go build --ldflags '-linkmode external -extldflags "-static"'  # 采用静态编译
    publish:
        image: plugins/docker
        registry: xxx
        username: xxx
        password: xxx
        email: xxx
        repo: xxx/container/kube-scheduler
        tags: ${DRONE_TAG=latest}
        dockerfile: dockerfile/Dockerfile-kube-scheduler
        insecure: true
        when:
            event: [push, tag]
```

3. Dockerfile 静态编译连基础镜像都省了
```
$ cat dockerfile/Dockerfile-kube-scheduler
FROM scratch
COPY cmd/kube-scheduler/kube-scheduler /
CMD ["/kube-scheduler"]
```
后面再补上CD的配置
